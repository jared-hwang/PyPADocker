"""Function to generate matched solutions to the KV envelope equations

The matched envelope is generated by an iterative method described in the following paper and Master's thesis:

Steven M. Lund, Sven H. Chilton, and Edward P. Lee, "Efficient computation of matched solutions of the Kapchinskij-Vladimirskij envelope equations for periodic focusing lattices," Phys. Rev. ST Accel. Beams 9, 064201 (2006)

Sven Chilton, "Implementation of an iterative matching scheme for the Kapchinskij-Vladimirskij equations in WARP," UC Berkeley Nuclear Engineering Department, Master's Thesis, March 2008.  See also LBL Report Number ?to be added?  

The functions listed below are included in this module.  To access more detailed documentation on a given function, enter either help(function_name) or doc(function_name) into the Python command line.  The matching is accomplished by describing an applied focusing lattice in WARP variables and beam parameters and then calling Match().  All arguments can be left as default for most "normal" applications with specified perveance (via beam current and energy) and emittance that are auto-set from WARP inputs.  Numerous options can be set to refine the numerical tolerances and parameter choices associated with the specification of the matched solution.  


  - Match(): Overarching matching function called to generate the matched beam envelope.  Composed of all the functions listed below:


  
  - Bar(): Takes the period average of an array of discretized data using Simpson's Rule.
  - HillSolve(): Solves Hill's Equation given an array of focusing function values, an array of axial coordinate values and initial conditions.
  - subdom(): If the lattice focusing function has jump discontinuities, this function breaks the lattice period into subdomains between the discontinuities.
  - kblock(): Breaks up arrays of lattice function values into subarrays between any jump discontinuities.
  - sigma0_func(): Calculates undepressed phase advances of given lattice focusing functions, and the basic trigonometric functions thereof.
  - latfunc(): Calls the three functions subdom(), kblock(), and sigma0_func() sets up arrays of evenly spaced points spanning the lattice period, and scans the lattice for any jump discontinuities and creates an array of associated break points.
  - ContLimit(): Calculates the continuous limit radii and associated beam parameters.
  - Beta0(): Calculates seed order principal orbits and betatron functions.
  - Seed(): Calculates seed order envelope radii and associated beam parameters.
  - Beta1(): Calculates general order principal orbits and betatron functions.
  - Iterate(): Calculates general order envelope radii and other beam parameters.
  - MatchGen(): For parameterizations other than the ``normal'' one (i.e., with perveance and emittances as the specified beam parameters) this generates the match by running Iterate() until a given fractional error tolerance between successively iterated beam radii is achieved.
  - emitfunc(): Finds the differences between the specified emittances and those consistent with test values of depressed phase advance.  Used in a root-finding loop to determine the depressed phase advances consistent with specified emittances in a ``hybridized,'' indirect implementation of the ``normal'' parameterization.
  - Qfunc(): Finds the difference between the specified perveance and that consistent with test values of depressed phase advance.  Used in a root-finding loop to determine the depressed phase advances consistent with the specified perveance in a ``hybridized,'' indirect implementation of the ``normal'' parameterization.
  - emitfunc2a(): Computes the difference dey between y-plane emittance consistent with y-plane depressed phase advance and previously specifed y-plane emittance.  Used in a root-finding loop to determine sigmay (the y-plane depressed phase advance) if only sigmax (the x-plane equivalent) is known.
  - emitfunc2b(): Computes the difference dex between x-plane emittance consistent with x-plane depressed phase advance and previously specifed x-plane emittance.  Used in a root-finding loop to determine sigmax (the x-plane depressed phase advance) if only sigmay (the y-plane equivalent) is known.
"""
# envmatch_KVinvariant.py    

# Iterated Matching (IM) Method for constructing matched beam envelopes 
# to to KV envelope equations.

# Sven Chilton and Steve Lund 
# Lawrence Berkeley National Lab

# Contact:
# Sven Chilton
# Lawrence Berkeley National Lab 
# BLDG 47R0112
# 1 Cyclotron Road 
# Berkeley,CA 94720-8201

# schilton@lbl.gov
# chilton@berkeley.edu
# (510) 495-2394


########################################################################
# Import necessary packages from warp and scipy                        #
########################################################################

from ..warp import *
from scipy import optimize
from scipy import integrate
from scipy import interpolate


########################################################################
# Add script name version and script documentation function            #
########################################################################


def envmatch_KVinvariantdoc():
    import envmatch_KVinvariant
    print  envmatch_KVinvariant.__doc__
  
  
########################################################################
# Overarching matching function                                        #
########################################################################

def Match(emitx='auto',emity='auto',sigmax='auto',sigmay='auto',
          SolCase='0',HybridCase='1',tol=1.e-6,rftol='auto',
          steps=1000,LatGen=True,error_stop=True):
    """
  Computes matched envelope radii and angles solving the KV equations using an iterative numerical method.  The periodic applied focusing lattice and beam parameters should be set up in WARP before calling this script.  The specification of the start and end of the lattice period is effectively given by the WARP variables top.zlatstart (starting phase) and top.zlatperi (lattice period).  
  
  Optional Input parameters:
  
    Beam:
  
    - emitx  = 'auto': x-plane beam rms edge emittance [meter-radian] defaults to top.emitx
    - emity  = 'auto': y-plane beam rms edge emittance [meter-radian] defaults to top.emity
    - sigmax = 'auto': x-plane depressed phase advance [rad/period], calculated from the lattice and other beam parameters by default
    - sigmay = 'auto': y-plane depressed phase advance [rad/period], calculated from the lattice and other beam parameters by default
  
    Solution Case:
     
    - SolCase = '0':  focusing lattice + Q, emitx, emity specified (default case)
      SolCase = '1':  focusing lattice + Q, sigmax, sigmay specified 
      SolCase = '2':  focusing lattice + emitx, emity, sigmax, sigmay specified: this case is only applicable when all beam parameters exhibit transverse plane symmetry
      SolCase = '2a': focusing lattice + emitx, emity,  sigmax specified
      SolCase = '2b': focusing lattice + emitx, emity,  sigmay specified
      SolCase = '3a': focusing lattice + emitx, sigmax, sigmay specified
      SolCase = '3b': focusing lattice + emity, sigmax, sigmay specified
    - HybridCase = '1': For SolCase = '0', use hybrid^* case 1 with root finding 
      HybridCase = '2': For SolCase = '0', use hybrid^* case 2 with root finding
  
      ^*  See paper listed in package documentation for definitions of hybrid case etc.
      
    Numerics:
  
    - tol = 1.e-6: Maximum fractional difference over the lattice period between two successive iterated envelope radii in both the x- and y-planes to terminate matching iterations at.  
    - rftol = 'auto': Maximum fractional difference between two successive hybridized root finding matching iterations.  Reset to 10.*tol by default.
    - steps = 1000: Number of evenly spaced intervals per lattice period to calculate principal orbits and envelope functions on.
  
    Logic:
    
    - LatGen = True: Extracts all lattice properties needed for the match.  Should only be set to False if the same applied focusing lattice is used in consecutive envelope matching runs.
    - error_stop = True: If this flag is set to True (by default) the matching program stops if any error trap is tripped and prints a message explaining why the match was aborted.  If this flag is set to False, the program keeps running with possibly erroneous results.
  
  Match() returns the following for all SolCase settings:
  
    - iterations: number of iterations needed to achieve desired tolerance
    - tolachieved: actual fractional tolerance achieved (< tol)
    - Q: dimensionless beam perveance
    - emitx:   x-plane beam rms edge emittance [meter-radian]
    - emity:   y-plane beam rms edge emittance [meter-radian]
    - sigmax:  x-plane depressed phase advance [rad/period]
    - sigmay:  y-plane depressed phase advance [rad/period]
    - sigma0x: x-plane undepressed phase advance [rad/period]
    - sigma0y: y-plane undepressed phase advance [rad/period]
    - rx:  array of x-plane radii evaluated at steps+1 evenly spaced s-intervals
    - ry:  array of y-plane radii evaluated at steps+1 evenly spaced s-intervals
    - rxp: array of x-plane angles evaluated at steps+1 evenly spaced s-intervals
    - ryp: array of y-plane angles evaluated at steps+1 evenly spaced s-intervals
    - rxi: initial x-plane radius at the start of the lattice period [meters]
    - ryi: initial y-plane radius at the start of the lattice period [meters]
    - rxpi: initial x-plane angle at the start of the lattice period [meters]
    - rypi: initial y-plane angle at the start of the lattice period [meters]
    - sinitial: initial s value (start of the lattice period) [meters]
    - sfinal: final s value (end of the lattice period) [meters]
    - lperiod: lattice period length [meters]
    - ssample: array of steps+1 evenly spaced s-intervals [meters]
    
  If SolCase = '0', Match() also runs WARP's envelope package with the same axial step size to effectively load the matched envelope radii in WARP's native variables (i.e, rx => env.aenv, ry => env.benv, rxp => env.apenv, ryp => env.bpenv). The initial conditions (rxi => top.a0, ryi => top.b0, rxpi => top.ap0, rypi => top.bp0) are also set consistently in WARP.  
  
  For all parameterization cases other than 0 (SolCase != '0'), Match() prints a message suggesting that the user reset the WARP perveance Q and emittances emitx and emity consistently with those calculated in the matched envelope specification.  The perveance will normally be reset in WARP by varying the beam current. 
    """
    # --- Consistency Check
    if top.lrelativ != top.relativity:
        print 'top.lrelativ =', top.lrelativ 
        print 'but top.relativity =', top.relativity
        print 'Must set both consistently to True or False.'
        raise Exception('top.lrelativ and top.relativity not consistent')
    # --- Lattice Parameters
    global lperiod,sigma0x,sigma0y,si
    lperiod = top.tunelen
    if error_stop:
        assert lperiod > 0., 'Lattice period length must be strictly positive.'
    si = env.tunezs
    sinitial = si
    sfinal   = si+lperiod
    sigma0x = top.sigma0x*(pi/180.) # [rad], not [deg]
    sigma0y = top.sigma0y*(pi/180.)
  
    # --- Beam Parameters
    #     Dimensionless perveance
    Q = (top.zion*echarge*top.ibeam)/\
        (2.*pi*eps0*top.aion*amu*(top.gammabar*top.vbeam)**3)
    #     Emittances
    if emitx  == 'auto': emitx  = top.emitx
    if emity  == 'auto': emity  = top.emity
  
    # --- Numerics
    #     Ensure that the parameter steps is a positive integer
    steps = int(abs(steps))
    #     Reset root-finding tolerance rftol accordingly
    if rftol == 'auto': rftol = 10.*tol
    
    # Parameters for principal orbit calculations
    global cxi,cxpi,sxi,sxpi,cyi,cypi,syi,sypi
    cxi  = 1.;  cxpi = 0.;
    sxi  = 0.;  sxpi = 1.;
    cyi  = 1.;  cypi = 0.; 
    syi  = 0.;  sypi = 1.;
    
    # global iteration count list; useful in Case 0 parameterization
    global iternum
    iternum = [-1]
    
    if LatGen == True:
        # --- make sure lattice parameters and depressed phase advances are
        #     set consistently with each other
        latfunc(steps,error_stop)
      
    # --- make sure sigmax and sigmay are set properly
    if sigmax == 'auto': sigmax = sigma0x
    if sigmay == 'auto': sigmay = sigma0y
    if error_stop:
        assert sigmax <= sigma0x, 'Error: sigmax > sigma0x.  Choose a lower sigmax.'
        assert sigmay <= sigma0y, 'Error: sigmay > sigma0y.  Choose a lower sigmay.'
        #assert sigmax > 0., 'Depressed phase advance must be greater than 0.'
        #assert sigmay > 0., 'Depressed phase advance must be greater than 0.'
    
    # ---
    if   SolCase == '0':
        if Q == 0.:
            # This case, with no space-charge depression, is not typical.
            # Here, the envelope is given by the undepressed orbits, so the seed
            # iteration is exact to numerical tolerance
            # --- set derived parameters
            #     since there is no depression, there is no difference between
            #     undpressed and depressed phase advances
            sigmax = sigma0x
            sigmay = sigma0y
            # --- make sure continuous limit quantities are set
            ContLimit(SolCase,Q,emitx,emity,sigmax,sigmay)
            # --- generate seed iteration, which is exact to numerical tolerance
            #     in this case
            Seed('2',Q,emitx,emity,sigmax,sigmay)
            # --- set matched solution and other iteration quantities in case
            #     program is subsequently used for other purposes
            global rx1,ry1,rx,ry,rxp1,ryp1,rxp,ryp
            rx1  = rx0
            ry1  = ry0
            rx   = rx0
            ry   = ry0
            rxp1 = rxp0
            ryp1 = ryp0
            rxp  = rxp0
            ryp  = ryp0
            # --- set iterations 
            iterations  = 1
            tolachieved = 'NA'
        else:
            # This is the normal case: a beam will, in general, exhibit
            # space-charge effects
            # --- call the continuous limit function
            #     this will yield guess values of depressed phase advances
            #     consistent with specified perveance/emittances
            ContLimit(SolCase,Q,emitx,emity,sigmax,sigmay)
            # --- guess depressed phase advances from continuous limit estimates
            sigmaxg = emitx*lperiod/(rxbar**2)
            sigmayg = emity*lperiod/(rybar**2)
            # --- generate seed for first root-finding steps
            Seed(SolCase,Q,emitx,emity,sigmaxg,sigmayg)
            if   HybridCase == '1':
                xg = sigmaxg,sigmayg # guess starting values for sigmax and sigmay
                sigmax,sigmay = optimize.fsolve(emitfunc,xg,args=(Q,emitx,emity,tol),
                                                xtol = rftol)
            elif HybridCase == '2':
                xg = sigmaxg,sigmayg # guess starting values for sigmax and sigmay
                sigmax,sigmay = optimize.fsolve(Qfunc,xg,args=(Q,emitx,emity,tol),
                                                xtol = rftol)
            iterations = sum(iternum)
            tolachieved = MatchGen(HybridCase,True,Q,emitx,emity,
                                   sigmax,sigmay,tol)[1]
        # --- recast the envelope radius and angle blocks into arrays
        #     first make sure to remove any doubled points, i.e. the first 
        #     point of each subarray other than the first
        for i in range(1,len(rx)):
            rx[i]  = rx[i][1:]
            ry[i]  = ry[i][1:]
            rxp[i] = rxp[i][1:]
            ryp[i] = ryp[i][1:]
        rx  = concatenate(rx)
        ry  = concatenate(ry)
        rxp = concatenate(rxp)
        ryp = concatenate(ryp)
        # --- recast the envelope radius and angle arrays so the entries are
        #     spaced evenly in s
        intrx  = interpolate.splrep(sarr,rx,k=3,s=0)
        intry  = interpolate.splrep(sarr,ry,k=3,s=0)
        intrxp = interpolate.splrep(sarr,rxp,k=3,s=0)
        intryp = interpolate.splrep(sarr,ryp,k=3,s=0)
        rx     = interpolate.splev(ssample,intrx)
        ry     = interpolate.splev(ssample,intry)
        rxp    = interpolate.splev(ssample,intrxp)
        ryp    = interpolate.splev(ssample,intryp)    
        # --- extract initial radii and angles
        rxi  = rx[0]  # initial x radius
        ryi  = ry[0]  # initial y radius
        rxpi = rxp[0] # initial x angle
        rypi = ryp[0] # initial y angle
        # --- Link quantities calculated in Match() to standard WARP variables
        env.zl    = si             # starting z for envelope calculation (m)
        env.zu    = si+lperiod     # ending   z for envelope calculation (m)
        env.dzenv = lperiod/steps  # step  size  in envelope calculation (m)
        top.a0  = rx[0]; top.ap0 = rxp[0]
        top.b0  = ry[0]; top.bp0 = ryp[0]
        # --- Second order moments:
        ph = top.bph0
        top.xx0   = (rx[0]**2*cos(ph)**2 + ry[0]**2*sin(ph)**2)/4.
        top.xxp0  = (rx[0]*rxp[0]*cos(ph)**2 + ry[0]*ryp[0]*sin(ph)**2)/4.
        top.xpxp0 = ( (rxp[0]**2 + (emitx/rx[0])**2)*cos(ph)**2 + 
                      (ryp[0]**2 + (emity/ry[0])**2)*sin(ph)**2 )/4.
        top.yy0   = (rx[0]**2*sin(ph)**2 + ry[0]**2*cos(ph)**2)/4.
        top.yyp0  = (rx[0]*rxp[0]*sin(ph)**2 + ry[0]*ryp[0]*cos(ph)**2)/4.
        top.ypyp0 = ( (rxp[0]**2 + (emitx/rx[0])**2)*sin(ph)**2 + 
                      (ryp[0]**2 + (emity/ry[0])**2)*cos(ph)**2 )/4.
        top.xy0   = (rx[0]**2 - ry[0]**2)*sin(2.*ph)/8.
        top.xpy0  = (rx[0]*rxp[0] - ry[0]*ryp[0])*sin(2.*ph)/8.
        top.xyp0  = (rx[0]*rxp[0] - ry[0]*ryp[0])*sin(2.*ph)/8.
        top.xpyp0 = ( (rxp[0]**2 + (emitx/rx[0])**2) - 
                      (ryp[0]**2 + (emity/ry[0])**2) )*sin(2.*ph)/8.
        package("env"); generate(); step()
        return iterations,tolachieved,Q,emitx,emity,sigmax,sigmay,\
               sigma0x,sigma0y,rx,ry,rxp,ryp,rxi,ryi,rxpi,rypi,\
               sinitial,sfinal,lperiod,ssample
    # Non-default parameterizations
    elif SolCase == '1'  or SolCase == '2'  or SolCase == '2a' or \
         SolCase == '2b' or SolCase == '3a' or SolCase == '3b':
        if SolCase == '1' or SolCase == '2' or SolCase == '3a' or SolCase == '3b':
            iterations,tolachieved,Q,Qx,Qy,emitx,emity,sigmax,sigmay = \
              MatchGen(SolCase,True,Q,emitx,emity,sigmax,sigmay,tol)
            if   SolCase == '1':
                print 'For consistency, set'
                print 'Q = ', Q, '(already set)'
                print 'emitx = ', emitx
                print 'emity = ', emity
            elif SolCase == '2':
                print 'For consistency, set'
                print 'Q = ', Q
                print 'Consider resetting either beam current (top.ibeam)'
                print '  or beam velocity (top.vbeam) to achieve this'
                print 'emitx = ', emitx, '(already set)'
                print 'emity = ', emity, '(already set)'
            elif SolCase == '3a':
                print 'For consistency, set'
                print 'Q = ', Q
                print 'Consider resetting either beam current (top.ibeam)'
                print '  or beam velocity (top.vbeam) to achieve this'
                print 'emitx = ', emitx, '(already set)'
                print 'emity = ', emity
            elif SolCase == '3b':
                print 'For consistency, set'
                print 'Q = ', Q
                print 'Consider resetting either beam current (top.ibeam)'
                print '  or beam velocity (top.vbeam) to achieve this'
                print 'emitx = ', emitx
                print 'emity = ', emity, '(already set)'
        elif SolCase == '2a':
            # --- call the continuous limit function
            #     this will yield guess values of depressed phase advances
            #     consistent with specified perveance/emittances
            ContLimit(SolCase,Q,emitx,emity,sigmax,sigmay)
            sigmaxg = emitx*lperiod/(rxbar**2)
            sigmayg = emity*lperiod/(rybar**2)
            # --- generate seed for first root-finding steps
            Seed(SolCase,Q,emitx,emity,sigmaxg,sigmayg)
            # --- find sigmay such that the iterated values of emity equals the 
            #     specified value of emity
            yg = sigmayg # guess starting values for sigmay
            sigmay = optimize.newton(emitfunc2a,yg,args=(Q,emitx,emity,sigmax,tol),
                                     tol = rftol*emity)
            # --- generate match with emittances and depressed phase advances 
            #     specified
            itnum,tolachieved,Q,Qx,Qy,emitx,emity,sigmax,sigmay = \
              MatchGen('2',True,Q,emitx,emity,sigmax,sigmay,tol)
            iterations = sum(iternum)
            print 'For consistency, set'
            print 'Q = ', Q
            print 'Consider resetting either beam current (top.ibeam)'
            print '  or beam velocity (top.vbeam) to achieve this'
            print 'emitx = ', emitx, '(already set)'
            print 'emity = ', emity, '(already set)'
        elif SolCase == '2b':
            # --- call the continuous limit function
            #     this will yield guess values of depressed phase advances
            #     consistent with specified perveance/emittances
            ContLimit(SolCase,Q,emitx,emity,sigmax,sigmay)
            sigmaxg = emitx*lperiod/(rxbar**2)
            sigmayg = emity*lperiod/(rybar**2)
            # --- generate seed for first root-finding steps
            Seed(SolCase,Q,emitx,emity,sigmaxg,sigmayg)
            # --- find sigmax such that the iterated values of emitx equals the 
            #     specified value of emitx
            xg = sigmaxg # guess starting values for sigmax
            sigmax = optimize.newton(emitfunc2b,xg,args=(Q,emitx,emity,sigmax,tol),
                                     tol = rftol*emitx)
            # --- generate match with emittances and depressed phase advances 
            #     specified
            itnum,tolachieved,Q,Qx,Qy,emitx,emity,sigmax,sigmay = \
              MatchGen('2',True,Q,emitx,emity,sigmax,sigmay,tol)
            iterations = sum(iternum)
            print 'For consistency, set'
            print 'Q = ', Q
            print 'Consider resetting either beam current (top.ibeam)'
            print '  or beam velocity (top.vbeam) to achieve this'
            print 'emitx = ', emitx, '(already set)'
            print 'emity = ', emity, '(already set)'
        # --- recast the envelope radius and angle blocks into arrays
        #     first make sure to remove any doubled points, i.e. the first 
        #     point of each subarray other than the first
        for i in range(1,len(rx)):
            rx[i]  = rx[i][1:]
            ry[i]  = ry[i][1:]
            rxp[i] = rxp[i][1:]
            ryp[i] = ryp[i][1:]
        rx  = concatenate(rx)
        ry  = concatenate(ry)
        rxp = concatenate(rxp)
        ryp = concatenate(ryp)
        # --- recast the envelope radius and angle arrays so the entries are
        #     spaced evenly in s
        intrx  = interpolate.splrep(sarr,rx,k=3,s=0)
        intry  = interpolate.splrep(sarr,ry,k=3,s=0)
        intrxp = interpolate.splrep(sarr,rxp,k=3,s=0)
        intryp = interpolate.splrep(sarr,ryp,k=3,s=0)
        rx     = interpolate.splev(ssample,intrx)
        ry     = interpolate.splev(ssample,intry)
        rxp    = interpolate.splev(ssample,intrxp)
        ryp    = interpolate.splev(ssample,intryp)    
        # --- extract initial radii and angles
        rxi  = rx[0]  # initial x radius
        ryi  = ry[0]  # initial y radius
        rxpi = rxp[0] # initial x angle
        rypi = ryp[0] # initial y angle
        return iterations,tolachieved,Q,emitx,emity,sigmax,sigmay,\
               sigma0x,sigma0y,rx,ry,rxp,ryp,rxi,ryi,rxpi,rypi,\
               sinitial,sfinal,lperiod,ssample
    
    
########################################################################
# Set Up Utilities                                                     #
########################################################################

# Read in utility functions needed for the IM method

def Bar(data,sarray):
    """
  Period average function taken over the lattice period (lperiod).
  This is an approximate formula, using Simpson's Rule on a set of discretized data.
  Input:
    - data: Array of points over a finite domain.  When used in the context of envelope matching, make sure that the array being averaged contains data in the range [si,si+lperiod].
    - sarray: Array of s values corresponding to the data array being averaged.  In other words, for every i in range(len(sarray)), data[i] = func(sarray[i]), where func is some function.
    """
    return integrate.simps(data,x=sarray)/lperiod
  
########################################################################

def HillSolve(karray, sarray, xi, xpi):
    """
  Function to solve Hill's equation with input k(s) focusing function
  
    x''(s) + k(s)*x(s) = 0 
    x(s=s_i)  = x_i    initial coordinate 
    x'(s=s_i) = x'_i   initial angle
  
  Here, k(s) is input as an array.  Hill's equation is then solved approximately over the appropriate domain using the RK4 method.
  
  Inputs:
  
    - karray: Array of focusing function values k(s) for every s in sarray
    - sarray: Array of s (axial coordinate) values
    - xi    : Initial coordinate x(s=s_i)  = x_i
    - xpi   : Initial angle      x'(s=s_i) = x'_i
  
  Outputs:
  
    - xarray:  Array of points x(s)  for each s in sarray
    - xparray: Array of points xp(s) for each s in sarray
    """
    nsteps = len(sarray)-1
    HillArray = zeros((nsteps+1,2),'d')
    env.RK4HillSolve(karray,sarray[0],sarray[-1],xi,xpi,nsteps,HillArray)
    xarray  = HillArray[:,0]
    xparray = HillArray[:,1]
    return xarray,xparray
  
########################################################################
# Define Applied Focusing Lattice                                      #
########################################################################

# Read in functions pertaining to the lattice.    

def subdom(brkpts,steps):
    """
  Given an array of break points and a number of steps on the domain [brkpts[0],brkpts[-1]], break up the domain into subdomains as follows:
  [brkpts[0],brkpts[1]], [brkpts[1],brkpts[2]]... , [brkpts[-2],brkpts[-1]].
  Arguments:
    - brkpts: An array of break points containing the start and end points of a lattice period and the start and end points of any hard-edged elements in between.
    - steps:  Number of sampling points on the domain [brkpts[0],brkpts[-1]).
  Outputs:
    - sbreak: List containing all the subdomains as arrays.  Each subdomain array sbreak[i] contains roughly steps*(brkpts[i+1]-brkpts[i])/(brkpts[-1]-brkpts[0])+1 evenly spaced points on [brkpts[i],brkpts[i+1]].
    - sbreak2: List containing all the subdomains as arrays.  Each subdomain array sbreak2[i] contains roughly 2*steps*(brkpts[i+1]-brkpts[i])/(brkpts[-1]-brkpts[0])+1 evenly spaced points on [brkpts[i],brkpts[i+1]].
    - sarr: Array containing all the points in the sbreak[i] arrays, with any doubled point eliminated.
    - kappaxarr: Array of x-plane focusing strengths at each s in sarr
    - kappayarr: Array of y-plane focusing strengths at each s in sarr
    """
    nb = len(brkpts) # number of break points, counting end points
    # make sure grid is fine enough
    deltas = (brkpts[-1]-brkpts[0])/steps
    if deltas > lperiod/(2*nb):
        deltas = lperiod/(2*nb)
    nz = nb-1 # number of zones
    # --- break up the lattice period into subdomains, with points inside each 
    #     subdomain evenly spacedand shifted as necessary
    #     create a list of subdomain arrays
    sbreak  = []
    sbreak2 = []
    for i in range(nz):
        nsz = int((brkpts[i+1]-brkpts[i])/deltas)
        # make sure there is at least one point between the ends of each subdomain
        if nsz < 2: nsz = 2
        dsz = (brkpts[i+1]-brkpts[i])/nsz
        sbreak.append(brkpts[i]+dsz*arange(0,nsz+1))
    # --- create another list of subdomain arrays, this one with twice as fine a 
    #     grid as the first  
    for i in range(len(sbreak)):
        sbreak2.append(zeros(2*len(sbreak[i])-1,'d'))
        sbreak2[i][0] = sbreak[i][0]
        for j in range(1,len(sbreak[i])):
            sbreak2[i][2*j-1] = (sbreak[i][j-1]+sbreak[i][j])/2.
            sbreak2[i][2*j]   =  sbreak[i][j]
    # --- concatenate the list of subdomain arrays into a single array, 
    #     eliminating doubled points
    sarr = sbreak[0]
    for i in range(1,len(sbreak)):
        sarr = concatenate((sarr,sbreak[i][1:]))
    # --- create arrays of focusing function values
    kappaxarr = zeros(len(sarr),'d')
    kappayarr = zeros(len(sarr),'d')
    env.kappaxvec(sarr,kappaxarr,len(sarr))
    env.kappayvec(sarr,kappayarr,len(sarr))
      
    return sbreak,sbreak2,sarr,kappaxarr,kappayarr
  
########################################################################

def kblock(sbreak,sbreak2,ds):
    """
  This function is designed to be used after subdom(brkpts,steps).  That function breaks up the lattice period into subdomains.  This function, in turn, calculates the lattice focusing strengths at evenly spaced points in each subdomain.
  
  Arguments:
    - sbreak: List containing all the subdomains as arrays.  Each subdomain array sbreak[i] contains roughly steps*(brkpts[i+1]-brkpts[i])/(brkpts[-1]-brkpts[0])+1 evenly spaced points on [brkpts[i],brkpts[i+1]].
    - sbreak2: List containing all the subdomains as arrays.  Each subdomain array sbreak2[i] contains roughly 2*steps*(brkpts[i+1]-brkpts[i])/(brkpts[-1]-brkpts[0])+1 evenly spaced points on [brkpts[i],brkpts[i+1]].
    - ds: Infinitesimal s-spacing designed to eliminate problems associated with jump discontinuities in the lattice focusing functions.
  
  Outputs:
    - kappaxblock: List containing arrays of x-plane lattice focusing strengths at each point in the sbreak[i] arrays.
    - kappayblock: List containing arrays of y-plane lattice focusing strengths at each point in the sbreak[i] arrays.
    - kappaxblock2: List containing arrays of x-plane lattice focusing strengths at each point in the sbreak2[i] arrays.
    - kappayblock2: List containing arrays of y-plane lattice focusing strengths at each point in the sbreak2[i] arrays.
    """
    # --- Initialize lists of focusing strength values at each point 
    #     in each subdomain 
    kappaxblock  = []
    kappayblock  = []
    kappaxblock2 = []
    kappayblock2 = []
    for i in range(0,len(sbreak)):
        # --- Calculate focusing strength values at each point in the subdomain
        kx1 = zeros(len(sbreak[i]), 'd')
        ky1 = zeros(len(sbreak[i]), 'd')
        kx2 = zeros(len(sbreak2[i]),'d')
        ky2 = zeros(len(sbreak2[i]),'d')
        env.kappaxvec(sbreak[i], kx1,len(sbreak[i]))
        env.kappayvec(sbreak[i], ky1,len(sbreak[i]))
        env.kappaxvec(sbreak2[i],kx2,len(sbreak2[i]))
        env.kappayvec(sbreak2[i],ky2,len(sbreak2[i]))
        # --- Deal with both sides of any jump discontinuities appropriately
        kx1[0]  = env.kappax(sbreak[i][0]+ds)
        ky1[0]  = env.kappay(sbreak[i][0]+ds)
        kx1[-1] = env.kappax(sbreak[i][-1]-ds)
        ky1[-1] = env.kappay(sbreak[i][-1]-ds)
        kx2[0]  = env.kappax(sbreak2[i][0]+ds)
        ky2[0]  = env.kappay(sbreak2[i][0]+ds)
        kx2[-1] = env.kappax(sbreak2[i][-1]-ds)
        ky2[-1] = env.kappay(sbreak2[i][-1]-ds)
        # --- Append the focusing strength values on the subdomain to the 
        #     appropriate lists
        kappaxblock.append(kx1)
        kappayblock.append(ky1)
        kappaxblock2.append(kx2)
        kappayblock2.append(ky2)
    return kappaxblock,kappayblock,kappaxblock2,kappayblock2
  
########################################################################

def sigma0_func(error_stop):
    """
  Computes undepressed phase advances - as well as the cosines, sines, and tangents thereof - from the lattice focusing functions, which here are treated as blocks of arrays spanning each subdomain.
  
  Arguments:
    - error_stop  = True: Stops the program if an error trap is tripped
  Outputs:
    - sigma0x:    Undepressed x-plane phase advance [rad]
    - sigma0y:    Undepressed y-plane phase advance [rad]
    - cossigma0x: Cosine of undepressed x-plane phase advance
    - cossigma0y: Cosine of undepressed y-plane phase advance
    - sinsigma0x: Sine of undepressed x-plane phase advance
    - sinsigma0y: Sine of undepressed y-plane phase advance
    - tansigma0x: Tangent of undepressed x-plane phase advance
    - tansigma0y: Tangent of undepressed y-plane phase advance
  Outside of the output list, sigma0_func() also returns top.sigma0x and top.sigma0x, both of which are in degrees.
    """
    # --- Solve differential equations for principal orbits
    # --- Extract principal function and derivations into arrays
    #     Notation:
    #       c0x  => c_{0x}(s) 
    #       c0xp => d c_{0x}(s) /ds 
    #       etc.
    # --- Initialize lists of undepressed principal orbit values for each 
    #     subdomain array
    #print "Calculating undepressed principal orbits"
    c0x  = []
    c0xp = []
    s0x  = []
    s0xp = []
    c0y  = []
    c0yp = []
    s0y  = []
    s0yp = []
    for n in range(len(sbreak)):
        #print "n = ", n
        # --- First subdomain: sine-like and cosine-like initial conditions
        if n == 0:
            cxin  = cxi
            cxpin = cxpi
            sxin  = sxi
            sxpin = sxpi
            cyin  = cyi
            cypin = cypi
            syin  = syi
            sypin = sypi
        # --- Subsequent subdomains: set initial conditions to the final 
        #     conditions of the previous subdomain 
        else:
            cxin  = c0x[-1][-1]
            cxpin = c0xp[-1][-1]
            sxin  = s0x[-1][-1]
            sxpin = s0xp[-1][-1]
            cyin  = c0y[-1][-1]
            cypin = c0yp[-1][-1]
            syin  = s0y[-1][-1]
            sypin = s0yp[-1][-1]
        # --- Solve for undepressed principal orbits on the given subdomain
        #print "Solving for c0xn, c0xpn"
        c0xn,c0xpn = HillSolve(kappaxblock2[n],sbreak[n],cxin,cxpin)
        #print "Solving for s0xn, s0xpn"
        s0xn,s0xpn = HillSolve(kappaxblock2[n],sbreak[n],sxin,sxpin)
        #print "Solving for c0yn, c0ypn"
        c0yn,c0ypn = HillSolve(kappayblock2[n],sbreak[n],cyin,cypin)
        #print "Solving for s0yn, s0ypn"
        s0yn,s0ypn = HillSolve(kappayblock2[n],sbreak[n],syin,sypin)
        # --- Append arrays of undepressed principal orbit values on the subdomain 
        #     to the appropriate lists
        c0x.append( c0xn )
        c0xp.append(c0xpn)
        s0x.append( s0xn )
        s0xp.append(s0xpn)
        c0y.append( c0yn )
        c0yp.append(c0ypn)
        s0y.append( s0yn )
        s0yp.append(s0ypn)
    # --- calculate sin and cos of undepressed phase advances
    cossigma0x = 0.5*(c0x[-1][-1]+s0xp[-1][-1])
    cossigma0y = 0.5*(c0y[-1][-1]+s0yp[-1][-1])
    # --- Instability and error checks
    if abs(cossigma0x) <= 1:
        if s0x[-1][-1] >= 0.:
            sinsigma0x = sqrt(1-cossigma0x**2)
        else:
            if error_stop:
                print 'Warning: Undepressed x-plane phase advance > 180 degrees.'
                assert s0x[-1][-1] >= 0., 'Matching script aborted.'
            else:
                print 'Warning: Undepressed x-plane phase advance > 180 degrees.'
                print 'Lattice may not be stable.'
                print 'Continuing with matching script anyway.'
                sinsigma0x = -sqrt(1-cossigma0x**2)
    else:
        if error_stop:
            print 'Warning: Undepressed x-plane phase advance is complex.'
            assert abs(cossigma0x) <= 1, 'Matching script aborted.'
        else:
            print 'Warning: Undepressed x-plane phase advance is complex.'
            print 'Lattice may not be stable.'
            print 'Continuing with matching script anyway.'
            if s0x[-1][-1] >= 0.:
                sinsigma0x =  sqrt(1-cossigma0x**2+0j)
            else:
                sinsigma0x = -sqrt(1-cossigma0x**2+0j)
        
    if abs(cossigma0y) <= 1:
        if s0y[-1][-1] >= 0.:
            sinsigma0y = sqrt(1-cossigma0y**2)
        else:
            if error_stop:
                print 'Warning: Undepressed y-plane phase advance > 180 degrees.'
                assert s0y[-1][-1] >= 0., 'Matching script aborted.'
            else:
                print 'Warning: Undepressed y-plane phase advance > 180 degrees.'
                print 'Lattice may not be stable.'
                print 'Continuing with matching script anyway.'
                sinsigma0y = -sqrt(1-cossigma0y**2)
    else:
        if error_stop:
            print 'Warning: Undepressed y-plane phase advance is complex.'
            assert abs(cossigma0y) <= 1, 'Matching script aborted.'
        else:
            print 'Warning: Undepressed y-plane phase advance is complex.'
            print 'Lattice may not be stable.'
            print 'Continuing with matching script anyway.'
            if s0y[-1][-1] >=  0.:
                sinsigma0y =  sqrt(1-cossigma0y**2+0j)
            else:
                sinsigma0y = -sqrt(1-cossigma0y**2+0j)
        
    tansigma0x = sinsigma0x/cossigma0x
    tansigma0y = sinsigma0y/cossigma0y
  
    if type(cossigma0x) != complex    and type(sinsigma0x) != complex and \
       type(cossigma0x) != complex128 and type(sinsigma0x) != complex128:
        if sinsigma0x >= 0.:
            sigma0x = arccos(cossigma0x)
        else:
            sigma0x = 2*pi-arccos(cossigma0x)
      
    if type(cossigma0y) != complex    and type(sinsigma0y) != complex and \
       type(cossigma0y) != complex128 and type(sinsigma0y) != complex128:
        if sinsigma0y >= 0.:
            sigma0y = arccos(cossigma0y)
        else:
            sigma0y = 2*pi-arccos(cossigma0y)
            
    if type(cossigma0x) == complex    or type(sinsigma0x) == complex or \
       type(cossigma0x) == complex128 or type(sinsigma0x) == complex128:
        if sinsigma0x >= 0.:
            sigma0x = arccos(cossigma0x+0j)
        else:
            sigma0x = 2*pi-arccos(cossigma0x+0j)
        
    if type(cossigma0y) == complex    or type(sinsigma0y) == complex or \
       type(cossigma0y) == complex128 or type(sinsigma0y) == complex128:
        if sinsigma0y >= 0.:
            sigma0y = arccos(cossigma0y+0j)
        else:
            sigma0y = 2*pi-arccos(cossigma0y+0j)
      
    top.sigma0x = sigma0x*(180./pi)
    top.sigma0y = sigma0y*(180./pi)
  
    return sigma0x,sigma0y,cossigma0x,cossigma0y,sinsigma0x,sinsigma0y,\
           tansigma0x,tansigma0y
  
########################################################################

def latfunc(steps,error_stop):
    """
  Derives all necessary properties from lattice focusing functions.  Breaks up the lattice period into two arrays of evenly spaced points (one with twice the spacing size of the other).  From these arrays, latfunc() breaks up the lattice period into subdomains between any jump discontinuities in the lattice, and then evaluates the lattice focusing functions on all points within those subdomains.  From here, the undepressed phase advances are computed.
  
  Arguments:
    - steps: Number of evenly spaced intervals in which to divide the
      lattice period
    - error_stop = True: Stops the program if an error trap is tripped
  Global outputs:
    - ssample: Array of steps+1 evenly spaced points spanning the lattice period
    - ssample2: Array of 2*steps+1 evenly spaced points spanning the lattice
      period
    - deltas: Spacing between each point in ssample
    - ds: Infinitesimal s-spacing designed to eliminate problems associated with jump discontinuities in the lattice focusing functions.
    - brkpts: An array of break points containing the start and end points of a lattice period and the start and end points of any hard-edged elements in between.
    - sbreak: List containing all the subdomains as arrays.  Each subdomain array sbreak[i] contains roughly steps*(brkpts[i+1]-brkpts[i])/(brkpts[-1]-brkpts[0])+1 evenly spaced points on [brkpts[i],brkpts[i+1]].
    - sbreak2: List containing all the subdomains as arrays.  Each subdomain array sbreak2[i] contains roughly 2*steps*(brkpts[i+1]-brkpts[i])/(brkpts[-1]-brkpts[0])+1 evenly spaced points on [brkpts[i],brkpts[i+1]].
    - sarr: Array containing all the points in the sbreak[i] arrays, with any doubled point eliminated.
    - kappaxarr: Array of x-plane focusing strengths at each s in sarr
    - kappayarr: Array of y-plane focusing strengths at each s in sarr
    - kappaxblock: List containing arrays of x-plane lattice focusing strengths at each point in the sbreak[i] arrays.
    - kappayblock: List containing arrays of y-plane lattice focusing strengths at each point in the sbreak[i] arrays.
    - kappaxblock2: List containing arrays of x-plane lattice focusing strengths at each point in the sbreak2[i] arrays.
    - kappayblock2: List containing arrays of y-plane lattice focusing strengths at each point in the sbreak2[i] arrays.
    - sigma0x:    Undepressed x-plane phase advance [rad]
    - sigma0y:    Undepressed y-plane phase advance [rad]
    - cossigma0x: Cosine of undepressed x-plane phase advance
    - cossigma0y: Cosine of undepressed y-plane phase advance
    - sinsigma0x: Sine of undepressed x-plane phase advance
    - sinsigma0y: Sine of undepressed y-plane phase advance
    - tansigma0x: Tangent of undepressed x-plane phase advance
    - tansigma0y: Tangent of undepressed y-plane phase advance
    """
    global ssample,ssample2,deltas,ds,kappaxarr,kappayarr,\
           brkpts,sbreak,sbreak2,sarr,\
           kappaxblock,kappayblock,kappaxblock2,kappayblock2,\
           sigma0x,sigma0y,cossigma0x,cossigma0y,\
           sinsigma0x,sinsigma0y,tansigma0x,tansigma0y
    # --- Break up the lattice period into a number of evenly spaced intervals
    ssample  = si+lperiod*arange(0,steps+1)/steps
    # --- Break up the lattice period twice as finely
    ssample2 = si+lperiod*arange(0,2*steps+1)/(2*steps)
    # --- Interval width
    deltas   = lperiod/steps
    # --- Infinitesimal s-spacing
    ds       = deltas/(1.e6)
    
    # --- Calculate break points, i.e. end points and locations of any 
    #     jump discontinuities
    brkpts = array([si,si+lperiod])
    if top.quads:
        brkpts = concatenate((brkpts,top.quadzs,top.quadze))
    if top.heles:
        brkpts = concatenate((brkpts,top.helezs,top.heleze))
    
    # Sort the array and remove any doubled points
    brkpts = sort(brkpts)
    #brkpts = intersect1d_nu(brkpts,brkpts)
    Brkpts = [brkpts[0]] # dummy list in which to place all non-doubled points
    for i in range(1,len(brkpts)):
        if brkpts[i] != brkpts[i-1]:
            Brkpts.append(brkpts[i])
    brkpts = array(Brkpts)
    
    # --- Break up the lattice period into subdomains of evenly spaced points
    sbreak,sbreak2,sarr,kappaxarr,kappayarr = subdom(brkpts,steps)
    # --- Calculate focusing function valueson each subdomain
    kappaxblock,kappayblock,kappaxblock2,kappayblock2 = kblock(sbreak,sbreak2,ds)
    # --- Calculate undepressed phase advances
    sigma0x,sigma0y,cossigma0x,cossigma0y,sinsigma0x,sinsigma0y,\
    tansigma0x,tansigma0y = sigma0_func(error_stop)
  
    return True
  
########################################################################
# Continuous Limit                                                     #
########################################################################

#  --- read in functions to construct continuous limit envelopes used 
#      in forming a seed iteration

def ContLimit(SolCase,Q,emitx,emity,sigmax,sigmay):
    """
  Function that, based on solution type, calculates continuous limit
  quantities as a function of:
  
    - SolCase: solution case: '0', '1', '2', '2a', '2b', '3a', and '3b' implemented 
    - Q: perveance [1]
    - emitx: emit_x x rms edge emittance [m-rad]
    - emity: emit_y y rms edge emittance [m-rad]
    - sigmax: sigma_x x plane depressed phase advance [rad/period]
    - sigmay: sigma_y y plane depressed phase advance [rad/period]
  
  The lattice focusing functions (and sigma0x, sigma0y) are input as 
  global variables and must be defined.  The function returns the 
  following continuous limit variables as global:
     
    - rxbar: Bar(r_x) (period-averaged) x-envelope [m]
    - rybar: Bar(r_y) (period-averaged) y-envelope [m]
  
    - Qbar: Bar(Q) (period-averaged) dimensionless perveance [1] 
    - emitxbar: Bar(emit_x) (period-averaged) x-plane beam rms edge emittance [m-rad]
    - emitybar: Bar(emit_y) (period-averaged) y-plane beam rms edge emittance [m-rad]
  
  When numerical quantities are calculated, high precision is used to ensure that any accuracy limit will not influence subsequent applications.   
  
  Comments:
    In SolCase = '0': The structure is general and all limits should work.   
    In SolCase = '1': The formulas employed will not work for the zero space-charge limit with sigmaj = sigma0j, or equivalently, Q = 0.   The limit can be analyzed explicitly and the program generalized if this case is desired.  
    In SolCase = '2': We assume, that both of the sigmaj and both of the emitj are specified.  This can only be done if the inputs have sigma0x = sigma0y and emitx = emity.  The zero space charge limit should work.
    In SolCase = '2a': The structure is general and all limits should work
    In SolCase = '2b': The structure is general and all limits should work
    In SolCase = '3a': The structure is general and all limits should work
    In SolCase = '3b': The structure is general and all limits should work
    """
    global Qbar,emitxbar,emitybar,rxbar,rybar
    if   SolCase == '0':
        # --- set known parameters
        Qbar = Q
        emitxbar = emitx
        emitybar = emity
        # --- calculate cont envelope radii with numerical root finding
        emitg = (emitx + emity)/2.
        sig0g = (sigma0x + sigma0y)/2.
        rguess = (lperiod/sig0g)*sqrt(Qbar/2. + (1./2.)*sqrt(Qbar**2. + \
                  4.*(sig0g/lperiod)**2.*emitg**2.))
        # --- find rxbar and rybar: clc0 stands for continuous limit, case 0
        def clc0(x):
            return [(sigma0x/lperiod)**2*x[0] - 2.*Qbar/(x[0]+x[1]) - \
                    emitxbar**2/(x[0]**3), \
                    (sigma0y/lperiod)**2*x[1] - 2.*Qbar/(x[0]+x[1]) - \
                    emitybar**2/(x[1]**3)]
        # --- guess values of rxbar and rybar
        r0 = rguess,rguess
        # --- calculate rxbar and rybar with 2D Newton-like root-finding
        rxbryb = optimize.fsolve(clc0,r0,xtol=1.e-13)
        rxbar  = rxbryb[0]
        rybar  = rxbryb[1]
    elif SolCase == '1':
        # --- set known parameter
        Qbar = Q
        # --- use analytical formulas to calculate cont envelope radii
        rxbar = sqrt(2.*Qbar)*lperiod/sqrt((sigma0x**2-sigmax**2) + \
                     (sigma0x**2 - sigmax**2)**2/(sigma0y**2 - sigmay**2))
        rybar = sqrt(2.*Qbar)*lperiod/sqrt((sigma0y**2-sigmay**2) + \
                     (sigma0y**2 - sigmay**2)**2/(sigma0x**2 - sigmax**2))
        # --- calculate consistent cont focusing emittances  
        emitxbar = (sigmax/lperiod)*rxbar**2
        emitybar = (sigmay/lperiod)*rybar**2
    elif SolCase == '2':
        # --- set known parameters
        emitxbar = emitx
        emitybar = emity
        # --- use analytical formulas to calculate cont envelope radii
        rxbar = sqrt(emitxbar/(sigmax/lperiod))
        rybar = sqrt(emitybar/(sigmay/lperiod))
        # --- calculate consistent cont focusing perveance while averaging
        #     between two planes to improve accuracy
        Qbar = (1./2.)* \
               ( (sigma0x**2-sigmax**2)*rxbar*(rxbar+rybar)/(2.*lperiod**2) + \
                 (sigma0y**2-sigmay**2)*rybar*(rxbar+rybar)/(2.*lperiod**2) )
    elif SolCase == '2a':
        # --- set known parameters
        emitxbar = emitx
        emitybar = emity
        # --- use analytical formulas and when necessary Newton root-finding
        #     to calculate cont envelope radii
        rxbar = sqrt(emitxbar/(sigmax/lperiod))
        # --- quartic polynomial of which rybar is a root
        def rybarfunc(y):
            return ( ( sigma0y/lperiod)**2*y +
                     ( emitx**2/rxbar**3 -
                       ( sigma0x/lperiod )**2*rxbar
                     ) )*y**3 - emity**2
        # --- derivative of above polynomial
        def rybarfuncp(y):
            return 4.*(sigma0y/lperiod)**2*y**3 + \
                   3.*(emitx**2/rxbar**3 - (sigma0x/lperiod)**2*rxbar)*y**2
        # --- calculate remaining continuous limit envelope radius
        #     with Newton root-finding
        rybar = optimize.newton(rybarfunc,rxbar,fprime=rybarfuncp)
        # --- calculate consistent continuous focusing perveance 
        Qbar = (sigma0x**2-sigmax**2)*rxbar*(rxbar+rybar)/(2.*lperiod**2) 
    elif SolCase == '2b':
        # --- set known parameters
        emitxbar = emitx
        emitybar = emity
        # --- use analytical formulas and when necessary Newton root-finding
        #     to calculate cont envelope radii
        rybar = sqrt(emitybar/(sigmay/lperiod))
        # --- quartic polynomial of which rxbar is a root
        def rxbarfunc(x):
            return ( ( sigma0x/lperiod)**2*x +
                     ( emity**2/rybar**3 -
                       ( sigma0y/lperiod )**2*rybar
                     ) )*x**3 - emitx**2
        # --- derivative of above polynomial
        def rxbarfuncp(x):
            return 4.*(sigma0x/lperiod)**2*x**3 + \
                   3.*(emity**2/rybar**3 - (sigma0y/lperiod)**2*rybar)*x**2
        # --- calculate remaining continuous limit envelope radius
        #     with Newton root-finding
        rxbar = optimize.newton(rxbarfunc,rybar,fprime=rxbarfuncp)
        # --- calculate consistent continuous focusing perveance 
        Qbar = (sigma0y**2-sigmay**2)*rybar*(rxbar+rybar)/(2.*lperiod**2) 
    elif SolCase == '3a':
        # --- set known parameter
        emitxbar = emitx
        # --- use analytical formulas to calculate cont envelope radii
        rxbar = sqrt(emitxbar/(sigmax/lperiod))
        rybar = ((sigma0x**2-sigmax**2)/(sigma0y**2-sigmay**2))*rxbar
        # --- calculate remaining continuous limit emittance from specified
        #     parameters and previously calculated continuous limit quantities
        emitybar = sigmay*rybar**2/lperiod
        # --- calculate consistent continuous focusing perveance while averaging
        #     between two planes to improve accuracy
        Qbar = (1./2.)* \
               ( (sigma0x**2-sigmax**2)*rxbar*(rxbar+rybar)/(2.*lperiod**2) + \
                 (sigma0y**2-sigmay**2)*rybar*(rxbar+rybar)/(2.*lperiod**2) )
    elif SolCase == '3b':
        # --- set known parameter
        emitybar = emity
        # --- use analytical formulas to calculate cont envelope radii
        rybar = sqrt(emitybar/(sigmay/lperiod))
        rxbar = ((sigma0y**2-sigmay**2)/(sigma0x**2-sigmax**2))*rybar
        # --- calculate remaining emittance from specified parameters and
        #     previously calculated continuous limit quantities
        emitxbar = sigmax*rxbar**2/lperiod
        # --- calculate consistent cont focusing perveance while averaging
        #     between two planes to improve accuracy
        Qbar = (1./2.)* \
               ( (sigma0x**2-sigmax**2)*rxbar*(rxbar+rybar)/(2.*lperiod**2) + \
                 (sigma0y**2-sigmay**2)*rybar*(rxbar+rybar)/(2.*lperiod**2) )
    # --- dummy return for function
    return True
  
  
########################################################################
# Seed Iteration                                                       #
########################################################################

#  --- read in functions to generate seed iteration

def Beta0(sigmax0,sigmay0):
    """
  Function to calculate seed iteration betatron arrays as a function of:
  
    - sigmax0: sigma_x^0 seed x-plane depressed phase advance [rad/period]
    - sigmay0: sigma_y^0 seed y-plane depressed phase advance [rad/period]
   
  The lattice focusing functions (and sigma0x, sigma0y) are input as global variables and must be defined.  Also, the following continuous limit variables are input as global variables and must be defined (with the function ContLimit()):
  
    - rxbar: Bar(r_x) cont focusing x-envelope [m]
    - rybar: Bar(r_y) cont focusing y-envelope [m]
    - Qbar:  Bar(Q) cont focusing dimensionless perveance [1]
  
  Outputs:
  
    - betax0:  List of arrays of seed x-plane beta func values on s = [si,si+lperiod] [m].  Each array within the list contains function values on a subdomain between consecutive lattice break points.
    - betay0:  List of arrays of seed y-plane beta func values on s = [si,si+lperiod] [m].  Each array within the list contains function values on a subdomain between consecutive lattice break points.
    - betaxp0: List of arrays of values of the derivative of seed x-plane beta func on s = [si,si+lperiod] [#].  Each array within the list contains function values on a subdomain between consecutive lattice break points.
    - betayp0: List of arrays of values of the derivative of seed y-plane beta func on s = [si,si+lperiod] [#].  Each array within the list contains function values on a subdomain between consecutive lattice break points.
    - sigmax0: sigma_x^0 seed x-plane depressed phase advance [rad/period]
    - sigmay0: sigma_y^0 seed y-plane depressed phase advance [rad/period]
    """
    # --- Modify kappajblock2 arrays with continuous limit space charge effects
    kxblock = []
    kyblock = []
    for i in range(0,len(kappaxblock2)):
        kxblock.append(kappaxblock2[i]-2*Qbar/((rxbar+rybar)*rxbar))
        kyblock.append(kappayblock2[i]-2*Qbar/((rxbar+rybar)*rybar))
    # --- Solve differential equations for principal orbits
    # --- Extract principal function and derivations into interpolating functions
    #     Notation:
    #       cx0  => c_x^0(s) 
    #       cxp0 => d c_x^0(s) /ds 
    #       etc.
    # --- Initialize lists of seed order principal orbit values for each 
    #     subdomain array
    #print "Solving for 0th order depressed principal orbits"
    cx0  = []
    cxp0 = []
    sx0  = []
    sxp0 = []
    cy0  = []
    cyp0 = []
    sy0  = []
    syp0 = []
    for n in range(len(sbreak)):
        #print "n = ", n
        # --- First subdomain: sine-like and cosine-like initial conditions
        if n == 0:
            cxin  = cxi
            cxpin = cxpi
            sxin  = sxi
            sxpin = sxpi
            cyin  = cyi
            cypin = cypi
            syin  = syi
            sypin = sypi
        # --- Subsequent subdomains: set initial conditions to the final 
        #     conditions of the previous subdomain 
        else:
            cxin  = cx0[-1][-1]
            cxpin = cxp0[-1][-1]
            sxin  = sx0[-1][-1]
            sxpin = sxp0[-1][-1]
            cyin  = cy0[-1][-1]
            cypin = cyp0[-1][-1]
            syin  = sy0[-1][-1]
            sypin = syp0[-1][-1]
        # --- Solve for principal orbits on the given subdomain
        #print "Solving for cx0n, cxp0n"
        cx0n,cxp0n = HillSolve(kxblock[n],sbreak[n],cxin,cxpin)
        #print "Solving for sx0n, sxp0n"
        sx0n,sxp0n = HillSolve(kxblock[n],sbreak[n],sxin,sxpin)
        #print "Solving for cy0n, cyp0n"
        cy0n,cyp0n = HillSolve(kyblock[n],sbreak[n],cyin,cypin)
        #print "Solving for sy0n, syp0n"
        sy0n,syp0n = HillSolve(kyblock[n],sbreak[n],syin,sypin)
        # --- Append arrays of principal orbit values on the subdomain 
        #     to the appropriate lists
        cx0.append( cx0n )
        cxp0.append(cxp0n)
        sx0.append( sx0n )
        sxp0.append(sxp0n)
        cy0.append( cy0n )
        cyp0.append(cyp0n)
        sy0.append( sy0n )
        syp0.append(syp0n)
    # --- if either sigmax0 or sigmay0 is unknown, calculate it 
    #     from principal orbits
    if sigmax0 == 'unknown': 
        if abs(cx0[-1][-1]+sxp0[-1][-1]) < 2.:
            sigmax0 = arccos((cx0[-1][-1]+sxp0[-1][-1])/2.)
        else:
            sigmax0 = emitxbar*lperiod/(rxbar**2)
    if sigmay0 == 'unknown': 
        if abs(cy0[-1][-1]+syp0[-1][-1]) < 2.:
            sigmay0 = arccos((cy0[-1][-1]+syp0[-1][-1])/2.)
        else:
            sigmay0 = emitybar*lperiod/(rybar**2)
    # --- calculate sin and cos of depressed phase advances
    cossigmax0 = cos(sigmax0)
    sinsigmax0 = sin(sigmax0)
    cossigmay0 = cos(sigmay0)
    sinsigmay0 = sin(sigmay0)
    # --- calculate betatron functions and their derivatives 
    #     as lists of arrays
    betax0  = []
    betay0  = []
    betaxp0 = []
    betayp0 = []
    for i in range(len(sbreak)):
        betax0.append(
          sinsigmax0*sx0[i]**2/sx0[-1][-1] + \
            (sx0[-1][-1]/sinsigmax0)*\
            (cx0[i] +((cossigmax0-cx0[-1][-1])/sx0[-1][-1])*sx0[i])**2
                     )
        betay0.append(
          sinsigmay0*sy0[i]**2/sy0[-1][-1] + \
            (sy0[-1][-1]/sinsigmay0)*\
            (cy0[i] +((cossigmay0-cy0[-1][-1])/sy0[-1][-1])*sy0[i])**2
                     )
        betaxp0.append(
          2.*sinsigmax0*sx0[i]*sxp0[i]/sx0[-1][-1] + \
            (2.*sx0[-1][-1]/sinsigmax0)*\
            (cx0[i]  + ((cossigmax0-cx0[-1][-1])/sx0[-1][-1])*sx0[i])*\
            (cxp0[i] + ((cossigmax0-cx0[-1][-1])/sx0[-1][-1])*sxp0[i])
                      )
        betayp0.append(
          2.*sinsigmay0*sy0[i]*syp0[i]/sy0[-1][-1] + \
            (2.*sy0[-1][-1]/sinsigmay0)*\
            (cy0[i]  + ((cossigmay0-cy0[-1][-1])/sy0[-1][-1])*sy0[i])*\
            (cyp0[i] + ((cossigmay0-cy0[-1][-1])/sy0[-1][-1])*syp0[i])
                      )
    # --- return
    return betax0,betay0,betaxp0,betayp0,sigmax0,sigmay0
  
########################################################################

def Seed(SolCase,Q,emitx,emity,sigmax,sigmay):
    """
  Function to calculate seed iteration as a function of:
    
    - SolCase: solution case: '1' and '2' implemented 
    - Q: perveance [1]
    - emitx:  x rms edge emittance [m-rad]
    - emity:  y rms edge emittance [m-rad]
    - sigmax: x plane depressed phase advance [rad/period]
    - sigmay: y plane depressed phase advance [rad/period]
  
  It is assumed that the lattice and continuous limit quantities have been appropriately defined (input as global variables) before Seed() is called. The function returns as global variables:
  
    - Q0: Q^0 seed dimensionless perveance [1]
    - emitx0:  emit_x^0 seed x-emittance [m-rad]
    - emity0:  emit_y^0 seed y-emittance [m-rad]
    - sigmax0: sigma_x^0 seed x-plane depressed emittance [rad/period]
    - sigmay0: sigma_y^0 seed y-plane depressed emittance [rad/period]
  
    - rx0: List of arrays of seed x-plane envelope func values on s = [si,si+lperiod] [m].  Each array within the list contains function values on a subdomain between consecutive lattice break points.
    - ry0: List of arrays of seed y-plane envelope func values on s = [si,si+lperiod] [m].  Each array within the list contains function values on a subdomain between consecutive lattice break points.
  
    - rxp0: List of arrays of seed x-plane angle values on s = [si,si+lperiod] [rad].  Each array within the list contains function values on a subdomain between consecutive lattice break points.
    - ryp0: List of arrays of seed y-plane angle values on s = [si,si+lperiod] [rad].  Each array within the list contains function values on a subdomain between consecutive lattice break points.
    """
    global Q0,emitx0,emity0,sigmax0,sigmay0,rx0,ry0,rxp0,ryp0
    if   SolCase == '1':
        # --- set known parameters
        Q0 = Q
        sigmax0 = sigmax
        sigmay0 = sigmay
        # --- calculate betatron functions
        betax0,betay0,betaxp0,betayp0,sigmax0,sigmay0 = Beta0(sigmax0,sigmay0)
        # --- define intermediate quantities that will be used later to 
        #     calculate unspecified beam parameters
        bar1x = []
        bar1y = []
        for i in range(len(sbreak)):
            bar1x.append( 
              Bar(kappaxblock[i]*sqrt(betax0[i])-1./betax0[i]**(3/2.), sbreak[i])
                      )
            bar1y.append( 
              Bar(kappayblock[i]*sqrt(betay0[i])-1./betay0[i]**(3/2.), sbreak[i])
                      )
        # --- ratio of square roots of seed order emittances
        emitr0 = sum(bar1x)/sum(bar1y)
        bar2x = []
        bar2y = []
        for i in range(len(sbreak)):
            bar2x.append( 
              Bar(1./( sqrt(betax0[i]) + emitr0*sqrt(betay0[i]) ), sbreak[i])
                      )
            bar2y.append( 
              Bar(1./( sqrt(betax0[i])/emitr0 + sqrt(betay0[i]) ), sbreak[i])
                      )
        # --- calculate emittances from known parameters, betatron functions, 
        #     and intermediate quantities defined above
        emitx0 = 2.*Q0*sum(bar2x)/sum(bar1x)
        emity0 = 2.*Q0*sum(bar2y)/sum(bar1y)
        # --- check that both emittances are positive
        #     if not, use continuous estimates
        if emitx0 < 0 or emity0 < 0:
            emitx0 = sqrt(((sigma0x/lperiod)**2*rxbar - 2*Q0/(rxbar+rybar))*rxbar**3)
            emity0 = sqrt(((sigma0y/lperiod)**2*rybar - 2*Q0/(rxbar+rybar))*rybar**3)
    elif SolCase == '2'  or SolCase == '2a' or SolCase == '2b' or \
         SolCase == '3a' or SolCase == '3b' or SolCase == '0':
        if   SolCase == '2' or SolCase == '0':
            # --- set known parameters
            emitx0  = emitx
            emity0  = emity
            sigmax0 = sigmax
            sigmay0 = sigmay
            # --- calculate betatron functions
            betax0,betay0,betaxp0,betayp0,sigmax0,sigmay0 = Beta0(sigmax0,sigmay0)
            # --- define intermediate quantities that will be used later to 
            #     calculate unspecified beam parameters
            bar1x = []
            bar1y = []
            for i in range(len(sbreak)):
                bar1x.append( 
                  Bar(kappaxblock[i]*sqrt(betax0[i])-1./betax0[i]**(3/2.), sbreak[i]) 
                          )
                bar1y.append( 
                  Bar(kappayblock[i]*sqrt(betay0[i])-1./betay0[i]**(3/2.), sbreak[i])
                          )
            # --- ratio of square roots of seed order emittances
            emitr0 = sum(bar1x)/sum(bar1y)
            bar2x = []
            bar2y = []
            for i in range(len(sbreak)):
                bar2x.append( 
                  Bar(1./( sqrt(betax0[i]) + emitr0*sqrt(betay0[i]) ), sbreak[i]) 
                          )
                bar2y.append( 
                  Bar(1./( sqrt(betax0[i])/emitr0 + sqrt(betay0[i]) ), sbreak[i]) 
                          )
        elif SolCase == '2a':
            # --- set known parameters
            emitx0  = emitx
            emity0  = emity
            sigmax0 = sigmax
            # --- since sigmay0 is unknown, refer to it as such
            sigmay0 = 'unknown'
            # --- calculate betatron functions and sigmay0
            betax0,betay0,betaxp0,betayp0,sigmax0,sigmay0 = Beta0(sigmax0,sigmay0)
            # --- define intermediate quantities that will be used later to 
            #     calculate unspecified beam parameters
            bar1x = []
            bar1y = []
            for i in range(len(sbreak)):
                bar1x.append( 
                  Bar(kappaxblock[i]*sqrt(betax0[i])-1./betax0[i]**(3/2.), sbreak[i]) 
                          )
                bar1y.append( 
                  Bar(kappayblock[i]*sqrt(betay0[i])-1./betay0[i]**(3/2.), sbreak[i])
                          )
            # --- ratio of square roots of seed order emittances
            emitr0 = sum(bar1x)/sum(bar1y)
            bar2x = []
            bar2y = []
            for i in range(len(sbreak)):
                bar2x.append( 
                  Bar(1./( sqrt(betax0[i]) + emitr0*sqrt(betay0[i]) ), sbreak[i]) 
                          )
                bar2y.append( 
                  Bar(1./( sqrt(betax0[i])/emitr0 + sqrt(betay0[i]) ), sbreak[i]) 
                          )
        elif SolCase == '2b':
            # --- set known parameters
            emitx0  = emitx
            emity0  = emity
            sigmay0 = sigmay
            # --- since sigmax0 is unknown, refer to it as such
            sigmax0 = 'unknown'
            # --- calculate betatron functions and sigmax0
            betax0,betay0,betaxp0,betayp0,sigmax0,sigmay0 = Beta0(sigmax0,sigmay0)
            # --- define intermediate quantities that will be used later to 
            #     calculate unspecified beam parameters
            bar1x = []
            bar1y = []
            for i in range(len(sbreak)):
                bar1x.append( 
                  Bar(kappaxblock[i]*sqrt(betax0[i])-1./betax0[i]**(3/2.), sbreak[i]) 
                          )
                bar1y.append( 
                  Bar(kappayblock[i]*sqrt(betay0[i])-1./betay0[i]**(3/2.), sbreak[i])
                          )
            # --- ratio of square roots of seed order emittances
            emitr0 = sum(bar1x)/sum(bar1y)
            bar2x = []
            bar2y = []
            for i in range(len(sbreak)):
                bar2x.append( 
                  Bar(1./( sqrt(betax0[i]) + emitr0*sqrt(betay0[i]) ), sbreak[i]) 
                          )
                bar2y.append( 
                  Bar(1./( sqrt(betax0[i])/emitr0 + sqrt(betay0[i]) ), sbreak[i]) 
                          )
        elif SolCase == '3a':
            # --- set known parameters
            emitx0  = emitx
            sigmax0 = sigmax
            sigmay0 = sigmay
            # --- calculate betatron functions
            betax0,betay0,betaxp0,betayp0,sigmax0,sigmay0 = Beta0(sigmax0,sigmay0)
            # --- define intermediate quantities that will be used later to 
            #     calculate unspecified beam parameters
            bar1x = []
            bar1y = []
            for i in range(len(sbreak)):
                bar1x.append( 
                  Bar(kappaxblock[i]*sqrt(betax0[i])-1./betax0[i]**(3/2.), sbreak[i]) 
                          )
                bar1y.append( 
                  Bar(kappayblock[i]*sqrt(betay0[i])-1./betay0[i]**(3/2.), sbreak[i])
                          )
            # --- ratio of square roots of seed order emittances
            emitr0 = sum(bar1x)/sum(bar1y)
            bar2x = []
            bar2y = []
            for i in range(len(sbreak)):
                bar2x.append( 
                  Bar(1./( sqrt(betax0[i]) + emitr0*sqrt(betay0[i]) ), sbreak[i]) 
                          )
                bar2y.append( 
                  Bar(1./( sqrt(betax0[i])/emitr0 + sqrt(betay0[i]) ), sbreak[i]) 
                          )
            # --- calculate remaining seed emittance from known parameters and
            #     betatron functions
            emity0 = emitx0*(emitr0**2)
        elif SolCase == '3b':
            # --- set known parameters
            emity0  = emity
            sigmax0 = sigmax
            sigmay0 = sigmay
            # --- calculate betatron functions
            betax0,betay0,betaxp0,betayp0,sigmax0,sigmay0 = Beta0(sigmax0,sigmay0)
            # --- define intermediate quantities that will be used later to 
            #     calculate unspecified beam parameters
            bar1x = []
            bar1y = []
            for i in range(len(sbreak)):
                bar1x.append( 
                  Bar(kappaxblock[i]*sqrt(betax0[i])-1./betax0[i]**(3/2.), sbreak[i]) 
                          )
                bar1y.append( 
                  Bar(kappayblock[i]*sqrt(betay0[i])-1./betay0[i]**(3/2.), sbreak[i])
                          )
            # --- ratio of square roots of seed order emittances
            emitr0 = sum(bar1x)/sum(bar1y)
            bar2x = []
            bar2y = []
            for i in range(len(sbreak)):
                bar2x.append( 
                  Bar(1./( sqrt(betax0[i]) + emitr0*sqrt(betay0[i]) ), sbreak[i]) 
                          )
                bar2y.append( 
                  Bar(1./( sqrt(betax0[i])/emitr0 + sqrt(betay0[i]) ), sbreak[i]) 
                          )
            # --- calculate remaining seed emittance from known parameters and
            #     betatron functions
            emitx0 = emity0/(emitr0**2)
        # --- Calculate Q0 from known parameters, betatron functions, and 
        #     intermediate quantities defined above
        #     Use the average of the x- and y-planes
        Qx0 = (emitx0/2.)*sum(bar1x)/sum(bar2x)
        Qy0 = (emity0/2.)*sum(bar1y)/sum(bar2y)
        Q0  = ( Qx0 + Qy0 )/2.
        # --- check that both perveances are positive
        #     if not, use continuous estimates
        if Qx0 < 0 or Qy0 < 0:
            Qx0 = ( (sigma0x/lperiod)**2*rxbar - emitx0**2/(rxbar**3) )* \
                  (rxbar+rybar)/2.
            Qy0 = ( (sigma0y/lperiod)**2*rybar - emity0**2/(rybar**3) )* \
                  (rxbar+rybar)/2.
            Q0  = ( Qx0 + Qy0 )/2.
    else: raise Exception('Error: Seed Case Not Defined')
    # --- define new iteration
    rx0  = []
    ry0  = []
    rxp0 = []
    ryp0 = []
    for i in range(len(sbreak)):
        rx0.append( sqrt(emitx0*betax0[i]) )
        ry0.append( sqrt(emity0*betay0[i]) )
        rxp0.append(0.5*sqrt(emitx0/betax0[i])*betaxp0[i])
        ryp0.append(0.5*sqrt(emity0/betay0[i])*betayp0[i])
    # --- dummy return
    return True
  
  
########################################################################
# General Iteration                                                    #
########################################################################

#  --- read in functions for general IM method iterations and generation 
#      of matched envelope solutions to tolerance

def Beta1(sigmax1,sigmay1):
    """
  Function to calculate updated iteration betatron functions as a function of:
  
    - sigmax1: sigma_x^1 iteration x-plane depressed phase advance 
    - sigmay1: sigma_y^1 iteration y-plane depressed phase advance 
   
  The lattice focusing functions kappax[s] and kappay[s] (and sigma0x, sigma0y) are input as global variables and must be defined.  Also, the previous (or seed) iteration envelopes and perveance are input as global variables and must be defined:
  
    - Q0:  Previous iteration perveance [1]
    - rx0: List of arrays of previous iteration x-plane matched envelope values on s = [si,si+lperiod]  [m].  Each array within the list contains function values on a subdomain between consecutive lattice break points.
    - rx0: List of arrays of previous iteration y-plane matched envelope values on s = [si,si+lperiod]  [m].  Each array within the list contains function values on a subdomain between consecutive lattice break points.
   
  Outputs:
  
    - betax1: List of arrays of updated iteration x-plane betatron function values on s = [si,si+lperiod] [m].  Each array within the list contains function values on a subdomain between consecutive lattice break points.
    - betay1: List of arrays of updated iteration y-plane betatron function values on s = [si,si+lperiod] [m].  Each array within the list contains function values on a subdomain between consecutive lattice break points.
    - betaxp1: List of arrays of values of the derivative of updated x-plane beta func on s = [si,si+lperiod] [m].  Each array within the list contains function values on a subdomain between consecutive lattice break points.
    - betayp1: List of arrays of values of the derivative of updated y-plane beta func on s = [si,si+lperiod] [m].  Each array within the list contains function values on a subdomain between consecutive lattice break points.
    - sigmax1: sigma_x^1 iteration x-plane depressed phase advance 
    - sigmay1: sigma_y^1 iteration y-plane depressed phase advance 
    """
    # --- Set up rx0 and ry0 as interpolating functions so that HillSolve
    #     can use them in calculating the next order principal orbit arrays
    # --- Interpolate each subarray of rx0 and ry0 to subarrays with twice as 
    #     many points, so that HillSolve can use them in calculating the 
    #     next order principal orbit arrays
    rx0l = []
    ry0l = []
    for i in range(len(sbreak)):
        trx0 = interpolate.splrep(sbreak[i],rx0[i],k=3,s=0)
        try0 = interpolate.splrep(sbreak[i],ry0[i],k=3,s=0)
        rx0l.append(interpolate.splev(sbreak2[i],trx0))
        ry0l.append(interpolate.splev(sbreak2[i],try0))
    # --- Incorporate space-charge defocusing terms into lattice focusing terms
    kxblock = []
    kyblock = []
    for i in range(0,len(kappaxblock2)):
        kxblock.append( kappaxblock2[i]-2.*Q0/((rx0l[i]+ry0l[i])*rx0l[i]) )
        kyblock.append( kappayblock2[i]-2.*Q0/((rx0l[i]+ry0l[i])*ry0l[i]) )
    # --- Solve Hill's Equation for principal orbits
    # --- Extract principal function and derivatives as lists of arrays
    #     Notation:
    #       cx1  => c_x^i(s) 
    #       cxp1 => d c_x^i(s) /ds 
    #       etc.
    # --- Initialize lists of principal orbit values for each subdomain array
    #print "Solving for ith order depressed principal orbits"
    cx1  = []
    cxp1 = []
    sx1  = []
    sxp1 = []
    cy1  = []
    cyp1 = []
    sy1  = []
    syp1 = []
    for n in range(len(sbreak)):
        #print "n = ", n
        # --- First subdomain: sine-like and cosine-like initial conditions
        if n == 0:
            cxin  = cxi
            cxpin = cxpi
            sxin  = sxi
            sxpin = sxpi
            cyin  = cyi
            cypin = cypi
            syin  = syi
            sypin = sypi
        # --- Subsequent subdomains: set initial conditions to the final 
        #     conditions of the previous subdomain 
        else:
            cxin  = cx1[-1][-1]
            cxpin = cxp1[-1][-1]
            sxin  = sx1[-1][-1]
            sxpin = sxp1[-1][-1]
            cyin  = cy1[-1][-1]
            cypin = cyp1[-1][-1]
            syin  = sy1[-1][-1]
            sypin = syp1[-1][-1]
        # --- Solve for undepressed principal orbits on the given subdomain
        #print "Solving for cx1n, cxp1n"
        cx1n,cxp1n = HillSolve(kxblock[n],sbreak[n],cxin,cxpin)
        #print "Solving for sx1n, sxp1n"
        sx1n,sxp1n = HillSolve(kxblock[n],sbreak[n],sxin,sxpin)
        #print "Solving for cy1n, cyp1n"
        cy1n,cyp1n = HillSolve(kyblock[n],sbreak[n],cyin,cypin)
        #print "Solving for sy1n, syp1n"
        sy1n,syp1n = HillSolve(kyblock[n],sbreak[n],syin,sypin)
        # --- Append arrays of principal orbit values on the subdomain 
        #     to the appropriate lists
        cx1.append( cx1n )
        cxp1.append(cxp1n)
        sx1.append( sx1n )
        sxp1.append(sxp1n)
        cy1.append( cy1n )
        cyp1.append(cyp1n)
        sy1.append( sy1n )
        syp1.append(syp1n)
    # --- if either sigmax1 or sigmay1 is unknown, calculate it 
    #     from principal orbits
    if sigmax1 == 'unknown': 
        sigmax1 = arccos((cx1[-1][-1]+sxp1[-1][-1])/2.)
    if sigmay1 == 'unknown': 
        sigmay1 = arccos((cy1[-1][-1]+syp1[-1][-1])/2.)
    # --- calculate sin and cos of depressed phase advances
    cossigmax1 = cos(sigmax1)
    sinsigmax1 = sin(sigmax1)
    cossigmay1 = cos(sigmay1)
    sinsigmay1 = sin(sigmay1)
    # --- calculate betatron functions (arrays)
    betax1 = []
    betay1 = []
    for i in range(len(sbreak)):
        betax1.append(
          sinsigmax1*sx1[i]**2/sx1[-1][-1] + \
            (sx1[-1][-1]/sinsigmax1)*\
            (cx1[i] +((cossigmax1-cx1[-1][-1])/sx1[-1][-1])*sx1[i])**2
                     )
        betay1.append(
          sinsigmay1*sy1[i]**2/sy1[-1][-1] + \
            (sy1[-1][-1]/sinsigmay1)*\
            (cy1[i] +((cossigmay1-cy1[-1][-1])/sy1[-1][-1])*sy1[i])**2
                     )
    # --- calculate derivatives of betatron functions (arrays)
    betaxp1 = []
    betayp1 = []
    for i in range(len(sbreak)):
        betaxp1.append(
          2.*sinsigmax1*sx1[i]*sxp1[i]/sx1[-1][-1] + \
            (2.*sx1[-1][-1]/sinsigmax1)*\
            (cx1[i]  + ((cossigmax1-cx1[-1][-1])/sx1[-1][-1])*sx1[i])*\
            (cxp1[i] + ((cossigmax1-cx1[-1][-1])/sx1[-1][-1])*sxp1[i])
                      )
        betayp1.append(
          2.*sinsigmay1*sy1[i]*syp1[i]/sy1[-1][-1] + \
            (2.*sy1[-1][-1]/sinsigmay1)*\
            (cy1[i]  + ((cossigmay1-cy1[-1][-1])/sy1[-1][-1])*sy1[i])*\
            (cyp1[i] + ((cossigmay1-cy1[-1][-1])/sy1[-1][-1])*syp1[i])
                      )
    # --- return
    return betax1,betay1,betaxp1,betayp1,sigmax1,sigmay1
  
########################################################################

def Iterate(SolCase,Q,emitx,emity,sigmax,sigmay):
    """
  Function to calculate updated iteration of betatron and envelope functions as a function of:
  
    - SolCase: solution case: '1' and '2' implemented 
    - Q:       perveance [1]
    - emitx:   x rms edge emittance [m-rad]
    - emity:   y rms edge emittance [m-rad]
    - sigmax:  x plane depressed phase advance [rad/period]
    - sigmay:  y plane depressed phase advance [rad/period]
  
  It is assumed that the lattice and previous iteration variables been appropriately defined (input as global variables) before Iterate() is called by previous calls to Iterate() or Seed() (initial iteration case).  The function returns as global variables:
  
    - Q1:      Q^i iteration dimensionless perveance [1]
    - emitx1:  emit_x^i iteration x-emittance [m-rad]
    - emity1:  emit_y^i iteration y-emittance [m-rad]
    - sigmax1: sigma_x^i iteration x-plane depressed emittance [rad/period]
    - sigmay1: sigma_y^i iteration y-plane depressed emittance [rad/period]
  
    - rx1:  r_x^i(s) List of arrays of iteration x-plane envelope func values on s = [si,si+lperiod] [m].  Each array within the list contains function values on a subdomain between consecutive lattice break points.
    - ry1:  r_y^i(s) List of arrays of iteration y-plane envelope func values on s = [si,si+lperiod] [m].  Each array within the list contains function values on a subdomain between consecutive lattice break points.
    - rxp1: (r_x^i)'(s) List of arrays of iteration x-plane angle values on s = [si,si+lperiod] [rad].  Each array within the list contains function values on a subdomain between consecutive lattice break points.
    - ryp1: (r_y^i)'(s) List of arrays of iteration y-plane angle values on s = [si,si+lperiod] [rad].  Each array within the list contains function values on a subdomain between consecutive lattice break points.
  
  Also returned as a function object:
    
    - tol: fractional difference between updated and previous iteration [1] 
  
  and previous iteration functions are copied to the updated iteration (both as global variables) to prepare for further calls to Iterate(). That is,  
    
    rx0  = rx1 
    ry0  = ry1
    rxp0 = rxp1
    ryp0 = ryp1
  
  on exiting the update.
    """
    global Q0,Q1,emitx1,emity1,sigmax1,sigmay1,rx0,ry0,rx1,ry1,\
           rxp0,ryp0,rxp1,ryp1
    if   SolCase == '1':
        # --- set known parameters
        Q1 = Q
        Qx1= Q
        Qy1= Q
        sigmax1 = sigmax
        sigmay1 = sigmay
        # --- calculate betatron functions
        betax1,betay1,betaxp1,betayp1,sigmax1,sigmay1 = Beta1(sigmax1,sigmay1)
        # --- define intermediate quantities that will be used later to 
        #     calculate unspecified beam parameters
        bar1x = []
        bar1y = []
        for i in range(len(sbreak)):
            bar1x.append( 
              Bar(kappaxblock[i]*sqrt(betax1[i])-1./betax1[i]**(3/2.), sbreak[i])
                      )
            bar1y.append( 
              Bar(kappayblock[i]*sqrt(betay1[i])-1./betay1[i]**(3/2.), sbreak[i])
                      )
        # --- ratio of square roots of iterated emittances
        emitr1 = sum(bar1x)/sum(bar1y)
        bar2x = []
        bar2y = []
        for i in range(len(sbreak)):
            bar2x.append( 
              Bar(1./( sqrt(betax1[i]) + emitr1*sqrt(betay1[i]) ), sbreak[i])
                      )
            bar2y.append( 
              Bar(1./( sqrt(betax1[i])/emitr1 + sqrt(betay1[i]) ), sbreak[i])
                      )
        # --- calculate emittances from known parameters, betatron functions, 
        #     and intermediate quantities defined above
        emitx1 = 2.*Q1*sum(bar2x)/sum(bar1x)
        emity1 = 2.*Q1*sum(bar2y)/sum(bar1y)
    elif SolCase == '2'  or SolCase == '2a' or SolCase == '2b' or \
         SolCase == '3a' or SolCase == '3b' or SolCase == '0':
        if   SolCase == '2' or SolCase == '0':
            # --- set known parameters
            emitx1  = emitx
            emity1  = emity
            sigmax1 = sigmax
            sigmay1 = sigmay
            # --- calculate betatron functions
            betax1,betay1,betaxp1,betayp1,sigmax1,sigmay1 = Beta1(sigmax1,sigmay1)
            # --- define intermediate quantities that will be used later to 
            #     calculate unspecified beam parameters
            bar1x = []
            bar1y = []
            for i in range(len(sbreak)):
                bar1x.append( 
                  Bar(kappaxblock[i]*sqrt(betax1[i])-1./betax1[i]**(3/2.), sbreak[i]) 
                          )
                bar1y.append( 
                  Bar(kappayblock[i]*sqrt(betay1[i])-1./betay1[i]**(3/2.), sbreak[i])
                          )
            # --- ratio of square roots of iterated emittances
            emitr1 = sum(bar1x)/sum(bar1y)
            bar2x = []
            bar2y = []
            for i in range(len(sbreak)):
                bar2x.append( 
                  Bar(1./( sqrt(betax1[i]) + emitr1*sqrt(betay1[i]) ), sbreak[i]) 
                          )
                bar2y.append( 
                  Bar(1./( sqrt(betax1[i])/emitr1 + sqrt(betay1[i]) ), sbreak[i]) 
                          )
        elif SolCase == '2a':
            # --- set known parameters
            emitx1  = emitx
            emity1  = emity
            sigmax1 = sigmax
            # --- since sigmay1 is unknown, refer to it as such
            sigmay1 = 'unknown'
            # --- calculate betatron functions and sigmay1
            betax1,betay1,betaxp1,betayp1,sigmax1,sigmay1 = Beta1(sigmax1,sigmay1)
            # --- define intermediate quantities that will be used later to 
            #     calculate unspecified beam parameters
            bar1x = []
            bar1y = []
            for i in range(len(sbreak)):
                bar1x.append( 
                  Bar(kappaxblock[i]*sqrt(betax1[i])-1./betax1[i]**(3/2.), sbreak[i]) 
                          )
                bar1y.append( 
                  Bar(kappayblock[i]*sqrt(betay1[i])-1./betay1[i]**(3/2.), sbreak[i])
                          )
            # --- ratio of square roots of iterated emittances
            emitr1 = sum(bar1x)/sum(bar1y)
            bar2x = []
            bar2y = []
            for i in range(len(sbreak)):
                bar2x.append( 
                  Bar(1./( sqrt(betax1[i]) + emitr1*sqrt(betay1[i]) ), sbreak[i]) 
                          )
                bar2y.append( 
                  Bar(1./( sqrt(betax1[i])/emitr1 + sqrt(betay1[i]) ), sbreak[i]) 
                          )
        elif SolCase == '2b':
            # --- set known parameters
            emitx1  = emitx
            emity1  = emity
            sigmay1 = sigmay
            # --- since sigmax1 is unknown, refer to it as such
            sigmax1 = 'unknown'
            # --- calculate betatron functions and sigmax1
            betax1,betay1,betaxp1,betayp1,sigmax1,sigmay1 = Beta1(sigmax1,sigmay1)
            # --- define intermediate quantities that will be used later to 
            #     calculate unspecified beam parameters
            bar1x = []
            bar1y = []
            for i in range(len(sbreak)):
                bar1x.append( 
                  Bar(kappaxblock[i]*sqrt(betax1[i])-1./betax1[i]**(3/2.), sbreak[i]) 
                          )
                bar1y.append( 
                  Bar(kappayblock[i]*sqrt(betay1[i])-1./betay1[i]**(3/2.), sbreak[i])
                          )
            # --- ratio of square roots of iterated emittances
            emitr1 = sum(bar1x)/sum(bar1y)
            bar2x = []
            bar2y = []
            for i in range(len(sbreak)):
                bar2x.append( 
                  Bar(1./( sqrt(betax1[i]) + emitr1*sqrt(betay1[i]) ), sbreak[i]) 
                          )
                bar2y.append( 
                  Bar(1./( sqrt(betax1[i])/emitr1 + sqrt(betay1[i]) ), sbreak[i]) 
                          )
        elif SolCase == '3a':
            # --- set known parameters
            emitx1  = emitx
            sigmax1 = sigmax
            sigmay1 = sigmay
            # --- calculate betatron functions
            betax1,betay1,betaxp1,betayp1,sigmax1,sigmay1 = Beta1(sigmax1,sigmay1)
            # --- define intermediate quantities that will be used later to 
            #     calculate unspecified beam parameters
            bar1x = []
            bar1y = []
            for i in range(len(sbreak)):
                bar1x.append( 
                  Bar(kappaxblock[i]*sqrt(betax1[i])-1./betax1[i]**(3/2.), sbreak[i]) 
                          )
                bar1y.append( 
                  Bar(kappayblock[i]*sqrt(betay1[i])-1./betay1[i]**(3/2.), sbreak[i])
                          )
            # --- ratio of square roots of iterated emittances
            emitr1 = sum(bar1x)/sum(bar1y)
            bar2x = []
            bar2y = []
            for i in range(len(sbreak)):
                bar2x.append( 
                  Bar(1./( sqrt(betax1[i]) + emitr1*sqrt(betay1[i]) ), sbreak[i]) 
                          )
                bar2y.append( 
                  Bar(1./( sqrt(betax1[i])/emitr1 + sqrt(betay1[i]) ), sbreak[i]) 
                          )
            # --- calculate remaining seed emittance from known parameters and
            #     betatron functions
            emity1 = emitx1*(emitr1**2)
        elif SolCase == '3b':
            # --- set known parameters
            emity1  = emity
            sigmax1 = sigmax
            sigmay1 = sigmay
            # --- calculate betatron functions
            betax1,betay1,betaxp1,betayp1,sigmax1,sigmay1 = Beta1(sigmax1,sigmay1)
            # --- define intermediate quantities that will be used later to 
            #     calculate unspecified beam parameters
            bar1x = []
            bar1y = []
            for i in range(len(sbreak)):
                bar1x.append( 
                  Bar(kappaxblock[i]*sqrt(betax1[i])-1./betax1[i]**(3/2.), sbreak[i]) 
                          )
                bar1y.append( 
                  Bar(kappayblock[i]*sqrt(betay1[i])-1./betay1[i]**(3/2.), sbreak[i])
                          )
            # --- ratio of square roots of iterated emittances
            emitr1 = sum(bar1x)/sum(bar1y)
            bar2x = []
            bar2y = []
            for i in range(len(sbreak)):
                bar2x.append( 
                  Bar(1./( sqrt(betax1[i]) + emitr1*sqrt(betay1[i]) ), sbreak[i]) 
                          )
                bar2y.append( 
                  Bar(1./( sqrt(betax1[i])/emitr1 + sqrt(betay1[i]) ), sbreak[i]) 
                          )
            # --- calculate remaining seed emittance from known parameters and
            #     betatron functions
            emitx1 = emity1/(emitr1**2)
        # --- Calculate Q1 from known parameters and betatron functions.  
        #     Use the average of the x- and y-planes
        Qx1 = (emitx1/2.)*sum(bar1x)/sum(bar2x)
        Qy1 = (emity1/2.)*sum(bar1y)/sum(bar2y)
        Q1  = ( Qx1 + Qy1 )/2.
        # --- check that both perveances are positive
        #     if not, use continuous estimates
        if Qx1 < 0 or Qy1 < 0:
            Qx1 = ( (sigma0x/lperiod)**2*rxbar - emitx1**2/(rxbar**3) )* \
                  (rxbar+rybar)/2.
            Qy1 = ( (sigma0y/lperiod)**2*rybar - emity1**2/(rybar**3) )* \
                  (rxbar+rybar)/2.
            Q1  = ( Qx1 + Qy1 )/2.
    else: raise Exception('Error: Parameterization Case Not Defined')
    # --- construct updated iteration envelope functions from betatron functions
    rx1  = []
    ry1  = []
    rxp1 = []
    ryp1 = []
    for i in range(len(sbreak)):
        rx1.append( sqrt(emitx1*betax1[i]) )
        ry1.append( sqrt(emity1*betay1[i]) )
        rxp1.append(0.5*sqrt(emitx1/betax1[i])*betaxp1[i])
        ryp1.append(0.5*sqrt(emity1/betay1[i])*betayp1[i])
    # --- sample difference from present to previous iterations to calculate 
    #     a maximum value of the tolerance achieved
    ittolxlist = []
    ittolylist = []
    for i in range(len(sbreak)):
        ittolxlist.append(max(abs((rx1[i]-rx0[i])/rx1[i])))
        ittolylist.append(max(abs((ry1[i]-ry0[i])/ry1[i])))
    ittolx  = max(ittolxlist)
    ittoly  = max(ittolylist)
    ittol = max(ittolx,ittoly)
    # --- save envelope iteration and perveance in previous "0" iteration
    Q0   = Q1
    rx0  = rx1
    ry0  = ry1
    rxp0 = rxp1
    ryp0 = ryp1
    # --- return iteration properties
    return ittol,Qx1,Qy1,emitx1,emity1
  
########################################################################

def MatchGen(SolCase,SeedGen,Q,emitx,emity,sigmax,sigmay,tol):
    """
  Function to calculate matched solution to a fractional tolerance tol that is globally input as a function of the following input parameters:
  
    - SolCase: solution case: only cases 1 and 2 are implemented
    - SeedGen: generate seed iteration to start (True or False).  If False, the seed iteration must already be generated  by some other means such as prior calls to MatchGen() 
    - sigmax: x plane depressed phase advance [rad/period]
    - sigmay: y plane depressed phase advance [rad/period]
  
  Depending on SolCase, global parameters among 
  
    - Q: perveance [1]
    - emitx: x rms edge emittance [m-rad]
    - emity: y rms edge emittance [m-rad]
   
  will also be used in constructing the matched envelope solution.  The parameters not needed under SolCase will be reset to consistent values  using the applied parameters and the matched envelope solution.  The matched envelope functions are returned as global variables:
  
    - rx: array of x-plane matched envelope function values on s = [si,si+lperiod] [m]
    - ry: array of y-plane matched envelope function values on s = [si,si+lperiod] [m]
  
  The function call to MatchGen() returns:
  
    itnum,ittol,Q,Qx1,Qy1,emitx1,emity1 
      
    - itnum: number of iterations needed to achieve fractional error tol
    - ittol: actual tolerance achieved
    - Q: perveance consistent with final iteration
    - Qx1: x-plane perveance consistent with final iteration 
    - Qy1: y-plane perveance consistent with final iteration 
    - emitx1: x-plane emittance consistent with final iteration 
    - emity1: y-plane emittance consistent with final iteration 
  
  Also, itnum is used to reset a global variable iternum that is used for 
  data structure compatibility issues with other functions.
    """
    global rx,ry,rxp,ryp
    # --- generate seed iteration
    if SeedGen == True:
        # --- generate continuous limit approximation estimates
        ContLimit(SolCase,Q,emitx,emity,sigmax,sigmay)
        # --- generate actual seed iteration
        Seed(SolCase,Q,emitx,emity,sigmax,sigmay)
    # --- iterate solution till specified tolerance is achieved
    ittol = 1 # initialize while loop with a dummy iteration tolerance value
    itnum = 0 # initialize while loop with zeroth order iteration number
    while ittol >= tol:
        #print "Iteration number = ", itnum+1
        ittol,Qx1,Qy1,emitx1,emity1 = \
          Iterate(SolCase,Q,emitx,emity,sigmax,sigmay)
        itnum = itnum+1
    # --- reset any parameters consistent with calculated solution that
    #     are NOT (or should not be) specified under the solution case
    if   SolCase == '1':
        emitx = emitx1; emity = emity1; top.emitx = emitx; top.emity = emity
    elif SolCase == '2':
        Q = Q1
    elif SolCase == '2a':
        Q = Q1; sigmay = sigmay1; top.sigmay = (180/pi)*sigmay
    elif SolCase == '2b':
        Q = Q1; sigmax = sigmax1; top.sigmax = (180/pi)*sigmax
    elif SolCase == '3a':
        Q = Q1; emity = emity1; top.emity = emity
    elif SolCase == '3b':
        Q = Q1; emitx = emitx1; top.emitx = emitx
    # --- set matched envelope functions calculated to tolerance
    rx  = rx0
    ry  = ry0
    rxp = rxp0
    ryp = ryp0
    # --- append iteration number itnum to global iteration list
    #     iternum for compatibility with various function uses
    iternum.append(itnum)
    # --- return itnum,ittol,Q,Qx1,Qy1,emitx,emity,sigmax,sigmay
    return itnum,ittol,Q,Qx1,Qy1,emitx,emity,sigmax,sigmay
  
########################################################################

def emitfunc(x,Q,emitx,emity,tol):
    """
  Define x = sigmax,sigmay
  Computes the differences between emittances consistent with x and previously specifed emittances.  These differences are denoted dex and dey.
    """
    ex,ey = MatchGen('1',False,Q,emitx,emity,x[0],x[1],tol)[5:7]
    dex = ex - emitx
    dey = ey - emity
    return dex,dey
  
########################################################################

def Qfunc(x,Q,emitx,emity,tol):
    """
  Define x = sigmax,sigmay
  Computes the differences between perveances consistent with x and previously specifed perveance.  These differences are denoted dQx and dQy.  Generally, dQx and dQy will be equal.
    """
    Qx,Qy = MatchGen('2',False,Q,emitx,emity,x[0],x[1],tol)[3:5]
    dQx = Qx - Q
    dQy = Qy - Q
    return dQx,dQy
  
########################################################################

def emitfunc2a(y,Q,emitx,emity,sigmax,tol):
    """
  Define y = sigmay
  Computes the difference dey between y-plane emittance consistent with sigmay and previously specifed y-plane emittance.
    """
    ex,ey = MatchGen('3a',False,Q,emitx,emity,sigmax,y,tol)[5:7]
    dex = ex - emitx
    dey = ey - emity
    return dey
  
########################################################################

def emitfunc2b(x,Q,emitx,emity,sigmay,tol):
    """
  Define x = sigmax
  Computes the difference dex between x-plane emittance consistent with sigmay and previously specifed x-plane emittance.
    """
    ex,ey = MatchGen('3b',False,Q,emitx,emity,x,sigmay,tol)[5:7]
    dex = ex - emitx
    dey = ey - emity
    return dex
  
########################################################################

